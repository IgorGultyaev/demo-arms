/**
 * @fileOverview Generated by @croc/generator-webclient:client-classes Yeoman-generator, v1.39.0.
 */
import lang = require("lib/core.lang");
import support = require("lib/domain/support");
import _DomainObject = require("lib/domain/DomainObject");
import _UnitOfWork = require("lib/domain/UnitOfWork");
import ComplexValue = require("lib/domain/ComplexValue");
import Big = require("big");
import LobPropValue = support.LobPropValue;

import { metadata, IDomainCollection, INavigationPropSet } from "lib/domain/.domain";
import { IDataFacade } from "lib/interop/.interop";

export const factory: any;

export class UnitOfWork extends _UnitOfWork {
	constructor(dataFacade: IDataFacade, options: _UnitOfWork.Options);
	createEmployee(props?: lang.Map<any>): Employee;
	createAddress(props?: lang.Map<any>): Address;
	createCountry(props?: lang.Map<any>): Country;
	createUser(props?: lang.Map<any>): User;
	createGroup(props?: lang.Map<any>): Group;
	createFilmCompany(props?: lang.Map<any>): FilmCompany;
	createPost(props?: lang.Map<any>): Post;
	createCity(props?: lang.Map<any>): City;
	createFilm(props?: lang.Map<any>): Film;

}

export class DomainObject extends _DomainObject {
	uow: UnitOfWork;
}


export interface UserRoleMeta extends metadata.EnumMeta {
	members: {
		"Admin": metadata.EnumMember;
		"User": metadata.EnumMember;
	};
}

export enum UserRole {
	Admin = 2,
	User = 4,
}
export namespace UserRole {
	export const meta: UserRoleMeta;
}

export interface EmployeeMeta extends metadata.EntityMeta {
	props: {
		"firstName": metadata.PropertyMeta;
		"lastName": metadata.PropertyMeta;
		"user": metadata.PropertyMeta;
		"fired": metadata.PropertyMeta;
	};
}
export type EmployeeNames = {
	readonly [P in keyof EmployeeMeta["props"] | keyof EmployeeMeta["complex"]]: string;
};

export class Employee extends DomainObject {
	static meta: EmployeeMeta;
	static NAMES: EmployeeNames;
	meta: EmployeeMeta;
	init(): void;
	"firstName": lang.ObservableProperty<string>;
	"lastName": lang.ObservableProperty<string>;
	"user": lang.ObservableGetter<IDomainCollection<User>>;
	"fired": lang.ObservableProperty<boolean>;
}

export interface AddressMeta extends metadata.EntityMeta {
	props: {
		"addressName": metadata.PropertyMeta;
		"city": metadata.PropertyMeta;
		"employee": metadata.PropertyMeta;
	};
}
export type AddressNames = {
	readonly [P in keyof AddressMeta["props"] | keyof AddressMeta["complex"]]: string;
};

export class Address extends DomainObject {
	static meta: AddressMeta;
	static NAMES: AddressNames;
	meta: AddressMeta;
	init(): void;
	"addressName": lang.ObservableProperty<string>;
	"city": lang.ObservableProperty<City>;
	"employee": lang.ObservableProperty<Employee>;
}

export interface CountryMeta extends metadata.EntityMeta {
	props: {
		"countryName": metadata.PropertyMeta;
		"city": metadata.PropertyMeta;
	};
}
export type CountryNames = {
	readonly [P in keyof CountryMeta["props"] | keyof CountryMeta["complex"]]: string;
};

export class Country extends DomainObject {
	static meta: CountryMeta;
	static NAMES: CountryNames;
	meta: CountryMeta;
	init(): void;
	"countryName": lang.ObservableProperty<string>;
	"city": lang.ObservableGetter<IDomainCollection<City>>;
}

export interface UserMeta extends metadata.EntityMeta {
	props: {
		"login": metadata.PropertyMeta;
		"role": metadata.PropertyMeta;
		"avatar": metadata.PropertyMeta;
		"password": metadata.PropertyMeta;
		"created": metadata.PropertyMeta;
		"lastLogin": metadata.PropertyMeta;
		"groups": metadata.PropertyMeta;
	};
}
export type UserNames = {
	readonly [P in keyof UserMeta["props"] | keyof UserMeta["complex"]]: string;
};

export class User extends DomainObject {
	static meta: UserMeta;
	static NAMES: UserNames;
	meta: UserMeta;
	init(): void;
	"login": lang.ObservableProperty<string>;
	"role": lang.ObservableProperty<UserRole>;
	"avatar": lang.ObservableProperty<LobPropValue>;
	"password": lang.ObservableProperty<string>;
	"created": lang.ObservableProperty<Date>;
	"lastLogin": lang.ObservableProperty<Date>;
	"groups": lang.ObservableGetter<IDomainCollection<Group>>;
}

export interface GroupMeta extends metadata.EntityMeta {
	props: {
		"name": metadata.PropertyMeta;
		"users": metadata.PropertyMeta;
		"roles": metadata.PropertyMeta;
	};
}
export type GroupNames = {
	readonly [P in keyof GroupMeta["props"] | keyof GroupMeta["complex"]]: string;
};

export class Group extends DomainObject {
	static meta: GroupMeta;
	static NAMES: GroupNames;
	meta: GroupMeta;
	init(): void;
	"name": lang.ObservableProperty<string>;
	"users": lang.ObservableGetter<IDomainCollection<User>>;
	"roles": lang.ObservableProperty<UserRole>;
}

export interface FilmCompanyMeta extends metadata.EntityMeta {
	props: {
		"filmCompany": metadata.PropertyMeta;
	};
}
export type FilmCompanyNames = {
	readonly [P in keyof FilmCompanyMeta["props"] | keyof FilmCompanyMeta["complex"]]: string;
};

export class FilmCompany extends DomainObject {
	static meta: FilmCompanyMeta;
	static NAMES: FilmCompanyNames;
	meta: FilmCompanyMeta;
	init(): void;
	"filmCompany": lang.ObservableProperty<string>;
}

export interface PostMeta extends metadata.EntityMeta {
	props: {
		"postName": metadata.PropertyMeta;
	};
}
export type PostNames = {
	readonly [P in keyof PostMeta["props"] | keyof PostMeta["complex"]]: string;
};

export class Post extends DomainObject {
	static meta: PostMeta;
	static NAMES: PostNames;
	meta: PostMeta;
	init(): void;
	"postName": lang.ObservableProperty<string>;
}

export interface CityMeta extends metadata.EntityMeta {
	props: {
		"cityName": metadata.PropertyMeta;
		"country": metadata.PropertyMeta;
		"address": metadata.PropertyMeta;
	};
}
export type CityNames = {
	readonly [P in keyof CityMeta["props"] | keyof CityMeta["complex"]]: string;
};

export class City extends DomainObject {
	static meta: CityMeta;
	static NAMES: CityNames;
	meta: CityMeta;
	init(): void;
	"cityName": lang.ObservableProperty<string>;
	"country": lang.ObservableProperty<Country>;
	"address": lang.ObservableGetter<IDomainCollection<Address>>;
}

export interface FilmMeta extends metadata.EntityMeta {
	props: {
		"filmName": metadata.PropertyMeta;
		"employee": metadata.PropertyMeta;
		"filmCompany": metadata.PropertyMeta;
	};
}
export type FilmNames = {
	readonly [P in keyof FilmMeta["props"] | keyof FilmMeta["complex"]]: string;
};

export class Film extends DomainObject {
	static meta: FilmMeta;
	static NAMES: FilmNames;
	meta: FilmMeta;
	init(): void;
	"filmName": lang.ObservableProperty<string>;
	"employee": lang.ObservableGetter<IDomainCollection<Employee>>;
	"filmCompany": lang.ObservableProperty<FilmCompany>;
}

export interface ModelMeta extends metadata.ModelMeta {
	enums: {
		UserRole: UserRoleMeta;
	};
	complex: {
	};
	entities: {
		Employee: EmployeeMeta;
		Address: AddressMeta;
		Country: CountryMeta;
		User: UserMeta;
		Group: GroupMeta;
		FilmCompany: FilmCompanyMeta;
		Post: PostMeta;
		City: CityMeta;
		Film: FilmMeta;
	};
}
export const meta: ModelMeta;
